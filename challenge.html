<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lotte!!</title>
    <meta name='viewport' content='width=device-width, user-scalable=no'/>

    <body>
        <div> PickUP Map!!</div>
    </body>
    <script type="module">
        import * as Three from "/three.js-master/build/three.js"
        import Stats from "/three.js-master/examples/jsm/libs/stats.module.js"
        import { KMZLoader} from "/three.js-master/examples/jsm/loaders/KMZLoader.js"
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r119/examples/jsm/controls/OrbitControls.js';
        import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';
        
        var camera, scene, renderer, clock, stats, light;
        var location;
        // 좌표 설정해오기
        var maejang_location = [[-25, 0, -13],[-25, 0, -8],[-25,0,5],[-18,0,-12],[-20,0,-7],[-20,0,-3],[-20,0,2],[-20,0,8],
        [-18,0,13],[-18, 0, 2],[-18,0,8],[-13,0,-12],[-13,0,-5],[-13,0,5],[-13,0,13],[-8,0,-12],[-8,0,-5],[0,0,-5],[-2,0,4],
        [5,0,-5],[2,0,4],[10,0,-12],[12.5,0,-7.5],[12.5,0,-2.5],[12.5,0,2.5],[13,0,13],[12.5,0,7.5],[17.5,0,-7.5],[17.5,0,-2.5],
        [17.5,0,5],[22,0,-12],[22,0,-7.5],[25,0,-5],[27.5,0,2.5],[27.5,0,7.5],[27,0,13],[32,0,-12],[32,0,-5],[32,0,2],[32,0,7.5]]
        var destination = [-5, 20, 10]
        var base_position = [0, 0, 25] // 시작위치는 25
        var floor = 3
        var root = []

        main(floor, destination, base_position);
        animate();

        function main(floor, destination, base_position) {

            initScene(floor, base_position);
            initMisc();
            initline(destination, base_position);

            document.body.appendChild( renderer.domElement);
            window.addEventListener( 'resize', onWindowResize, false);
        }

        // 초기위치를 사람 모양, 가게 이름은 사각 기둥에 위에 이름표 띄워놓기
        function initScene(floor, base_position){
            // 카메라 세팅(fov, aspect, near, far)
            // fov는 시야각(값이 커질수록 멀어짐)
            // asperct는 canvas 가로 세로 비율임(이건 그냥 국룰 따라가는게 나을듯)
            // near와 far은 렌더링되는 공간범위! 이건 좁게 설정하면 피사체가 잘려나감 무조건 크게
            camera = new THREE.PerspectiveCamera( 120, window.innerWidth / window.innerHeight, 1, 2000);
            // 첫 카메라 포지션 잡음(x, y, z) 참고로 좌, 우가 x축이고 z는 앞, 뒤이고 y가 위, 아래임
            camera.position.set( 0, 30, 35);

            // Scene 선언
            scene = new THREE.Scene();

            // 말 그대로 배곃색
            scene.background = new THREE.Color(0xFFFFFF);

            // 조명색이라고 생각하면됨. 모든 오브젝트를 비춰줌, 그림자 X
            scene.add(new THREE.AmbientLight(0xeeeeee));

            // 전체 후광 효과 주기 위해 DirectionalLight(한 방향으로 비추는 Light) 이용
            light = new THREE.DirectionalLight( 0xFFFFFF, 1);
            light.position.set(0, 20, 0);
            scene.add(light);

            // 기본 오브젝트, radis, tube, tubularSegments, radialSegments, p, q 순
            var geometry = new THREE.TorusKnotBufferGeometry( 25, 8, 75, 20);
            // MeshPhongMaterial은 반사 하이라이트있는 반짝이는 표면 재질(고급스러움을 더 하기 위함)
            var material = new THREE.MeshPhongMaterial({
                color: 0x0000a0,
                shininess: 150,
                specular : 0x222222
            });
            // Mesh 메소드를 이용해서 선언한 geometry랑 material 결합 한 오브젝트 생성
            location = new THREE.Mesh( geometry, material);
            // 스케일 지정
            location.scale.multiplyScalar( 1/30 );
            // 초기 위치 치정 <- QR코드랑 어떻게 비벼봐야하고,,,,
            //location.position.set(0, 0, 20)
            location.position.x = base_position[0]
            location.position.y = base_position[1]
            location.position.z = base_position[2]
            scene.add( location );

            /* 백화점 층 바닥(width, height, depth)
            var geometry = new THREE.BoxBufferGeometry( 15, 0.15, 15);
            var material = new THREE.MeshPhongMaterial({
                color : 0x00ff00,
                shininess: 150,
                specular: 0x111111,
                transparent: true
            });*/
            for(var i = 0; i < floor; i++){
                //var ground = new THREE.Mesh( geometry, material);
                // 바닥이 격자가 더 나아서 수정
                // THREE.GridHelper( size, divisions );
                var ground = new THREE.GridHelper(64, 64, 0x000000)
                //ground.scale.multiplyScalar( 1 );
                ground.position.y = i*12-1.5;
                scene.add( ground );
            }

            // 매장 배열로 받아서 위치 별로 사각형으로 세팅
            var geometry = new THREE.BoxBufferGeometry(3, 3, 3);
            var maejang_fig = new THREE.MeshLambertMaterial( { color: 0xfeb74c, map: new THREE.TextureLoader().load( '/three.js-master/examples/textures/square-outline-textured.png' ) } );
            for(var j = 0; j < maejang_location.length; j++){
                var maejang = new THREE.Mesh(geometry, maejang_fig);
                maejang.position.set(maejang_location[j][0], maejang_location[j][1]*10, maejang_location[j][2]);
                scene.add(maejang)
            }
        }

        //목적지를 향한 선 그리는 부분
        function initline(destination, base_position, root){
            console.log(destination)
            
            var material = new THREE.LineBasicMaterial({
                color: 0xff4040,
                // 선두께 ㅅㅂ;; 왜 안됨,,
                linewidth: 100,
            });
            
            var points=[];

            if (destination[1] == 5){
                //for 문 돌려서 root 별로 이동하게 하면 될듯
                points.push(new THREE.Vector3(10, 0, 3));
                points.push(new THREE.Vector3(0, 0, 0));
                points.push(new THREE.Vector3(0, 5, 0));
                points.push(new THREE.Vector3(destination[0], destination[1], destination[2]));
            }

            if (destination[1] == 10){
                points.push(new THREE.Vector3(base_position[0], base_position[1], base_position[2]));
                points.push(new THREE.Vector3(10, 0, 3));
                points.push(new THREE.Vector3(0, 0, 0));
                points.push(new THREE.Vector3(0, 5, 0));
                points.push(new THREE.Vector3(0, 10, 0));
                points.push(new THREE.Vector3(destination[0], destination[1], destination[2]));
            }
            if (destination[1] == 15){
                points.push(new THREE.Vector3(base_position[0], base_position[1], base_position[2]));
                points.push(new THREE.Vector3(10, 0, 3));
                points.push(new THREE.Vector3(0, 0, 0));
                points.push(new THREE.Vector3(0, 5, 0));
                points.push(new THREE.Vector3(0, 10, 0));
                points.push(new THREE.Vector3(0, 15, 0));
                points.push(new THREE.Vector3(destination[0], destination[1], destination[2]));
            }
            if (destination[1] == 20){
                points.push(new THREE.Vector3(base_position[0], base_position[1], base_position[2]));
                points.push(new THREE.Vector3(10, 0, 3));
                points.push(new THREE.Vector3(0, 0, 0));
                points.push(new THREE.Vector3(0, 5, 0));
                points.push(new THREE.Vector3(0, 10, 0));
                points.push(new THREE.Vector3(0, 15, 0));
                points.push(new THREE.Vector3(0, 20, 0));
                points.push(new THREE.Vector3(destination[0], destination[1], destination[2]));
            }

            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            var line = new THREE.Line(geometry, material);
            scene.add(line);
        }

        function initMisc(){
            //wdbgl은 렌더러임. antialias는 가장자리를 매끄럽게 하는 기능
            renderer = new THREE.WebGLRenderer({antialias: true});
            //캔버스가 흐려지는거 방지
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // 카메라를 회전시킬 수 있도록 해주는 변수 선언
            var controls = new OrbitControls( camera, renderer.domElement );
            // 카메라 초기 위치 세팅
            controls.target.set(0,2,0);
            controls.update();
            clock = new THREE.Clock();

            stats = new Stats();
            document.body.appendChild(stats.dom);
        }

        function onWindowResize(){
            // 마우스로 사이즈 조절
            // aspect를 그때그때 조절
            camera.aspect = window.innerWidth / window.innerHeight;
            // 카메라 투영 매트릭스를 업데이트. 매개 변수 변경 후에 호출해야함
            camera.updateProjectionMatrix();

            // 캔버스 size를 계속 업뎃
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 계속 애니메이션을 돌리기 위함 위한 함수
        function animate(){
            requestAnimationFrame(animate);
            render();

            stats.update();
        }

        function renderScene(){
            renderer.render(scene, camera);
        }

        // 피사체 돌려보리기
        function render(){
            var delta = clock.getDelta();

            renderScene();
            location.rotation.y += 2 * delta;
        }
    </script>
</html>